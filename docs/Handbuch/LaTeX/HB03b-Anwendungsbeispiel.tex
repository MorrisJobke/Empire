%!TEX root = Handbuch.tex

\lstset{
  literate= {Ö}{{\"O}}1 {Ä}{{\"A}}1 {Ü}{{\"U}}1 {ß}{{\ss}}1 {ü}{{\"u}}1
 {ä}{{\"a}}1 {ö}{{\"o}}1
 }

\section{Ausführliches Anwendungsbeispiel}
Im Folgenden soll ein Überblick über die Möglichkeiten dieses Programmes gegeben werden. Dazu nutzen wir das als Vorlage enthaltene Template und erstellen 3 Rechnungen an 2 Kunden mit jeweils unterschiedlichen Posten.

Zu Beginn wechseln wir in das Verzeichnis unserer Wahl und erstellen dort ein Repository:
\begin{lstlisting}[style=Bash]
$ mkdir Rechnungen
$ cd Rechnungen
$ emp init
\end{lstlisting}

Um in diesem Beispiel eine bessere Übersicht zu gewährleisten, kopieren wir außerdem das Template in den Ordner des Repositories. Im allgemeinen Fall ist es aber gleichgültig, wo sich das Template befindet.
\begin{lstlisting}[style=Bash]
$ cp <Pfad des Templates> ./invoice.htm
\end{lstlisting}


Wir definieren im Wurzelverzeichnis des Repositorys unsere persönlichen Daten, da diese in allen Rechnungen gleich sein sollen. Dazu zählen beim vordefinierten Template die Anschrift, die Bankverbindung und unsere Kontaktdaten:

\begin{lstlisting}[style=Bash]
$ emp add from_name "Max Mustermann"
$ emp add from_street Musterstraße
$ emp add from_city Musterstadt
$ emp add from_mobile 0111/1234567
$ emp add from_email "max.mustermann@example.org"
$ emp add from_ustidnr "DE999999999"
$ emp add acct_name "Musterbank"
$ emp add acct_nr 123456
$ emp add acct_blz 65432100
\end{lstlisting}

Dasselbe Ergebnis kann man auch mit dem iadd-Befehl erreichen. Auf diesen werden wir aber erst später zurückgreifen.


Im Anschluss erstellen wir für jeden Kunden einen Ordner und hinterlegen in diesem die Daten des Kunden:
\begin{lstlisting}[style=Bash]
$ mkdir Kunde1 Kunde2
$ cd Kunde1
$ emp add to_name "Muster Co."
$ emp add to_street "Musterallee 42"
$ emp add to_city "Musterhausen"
\end{lstlisting}

Die Bennenung der Ordner spielt hier keine Rolle (solange keine Collection mit dem gewünschten Namen existiert), sollte aber zur Förderung der Übersichtlichkeit sinnvoll bennant werden.

Für den 2. Kunden nutzen wir nun den addi-Befehl:
\begin{lstlisting}[style=Bash]
$ cd ../Kunde2
$ emp iadd ../invoice.htm
\end{lstlisting}

Es erfolgt eine interaktive Abfrage der im Template genutzten, aber im Repository noch nicht gesetzten Werte. Wir wollen nur die Kundendaten eintragen und überspringen die restlichen Abfragen mit der Enter-Taste.

Jetzt können wir unseren Zwischenstand mit dem show-Befehl überprüfen. Dazu nutzen wir folgendes Kommando:
\begin{lstlisting}[style=Bash]
$ emp show ../invoice.htm
\end{lstlisting}

Wir erhalten eine Auflistung aller bereits gesetzter Variablen und Collections. Zusätzlich werden die weiteren benötigen Variablen angezeigt. Falls weitere Werte existieren die nicht im Template benötigt werden, werden diese ebenfalls in einer gesonderten Kategorie angezeigt.

Nun erstellen wir eine Rechnung für Kunde 1. Dazu erstellen wir im Verzeichnis von Kunde 1 einen Ordner und füllen ihn mit den restlichen Informationen:

\begin{lstlisting}[style=Bash]
$ cd ../Kunde1
$ mkdir Auftrag1
$ emp iadd ../../invoice.htm
\end{lstlisting}

Die Collection wird nun folgendermaßen ge
TODO: Collection adden

Das Template kann nun zur fertigen Rechnung gerendert werden, da wir alle benötigten Werte hinzugefügt haben:
\begin{lstlisting}[style=Bash]
$ cd ../../Kunde1
$ emp render invoice.htm Kunde1/Auftrag1/invoice.htm
\end{lstlisting}

Im folgenden definieren wir die Variablen welche die Grundlage für die im Template enthaltene Collection benötigt werden. Um herauszufinden welche das sind bemühen wir den show-Befehl und übergeben das Template als Paramter:
\begin{lstlisting}[style=Bash]
$ emp show ../../invoice.htm 
\end{lstlisting}

Besonders interessant ist dabei der Abschnitt der vom Template genutzen, aber im Repository nicht enthaltenen Collections. Dort wird uns die Collection \grqq item\grqq mit den folgenden Werten angezeigt:

\begin{lstlisting}[style=Bash]
Collections:
============
Used by template and not defined(1):
	items, containing elements (got from Template):
		description  price        quantity     
		total        unit
\end{lstlisting}

Wir definieren nun also die 5 Variablen:
\begin{lstlisting}[style=Bash]
$ emp create description string
$ emp create price float
$ emp create quantity int
$ emp create total function
$ emp create unit string
\end{lstlisting}

Aus diesen Definitionen kann nun eine Collection erstellt werden:
\begin{lstlisting}[style=Bash]
$ emp cadd items  description price quantity total unit
\end{lstlisting}

Danach sollten noch ein paar Zeilen zu der eben erstellten Collection hinzugefügt werden:
\begin{lstlisting}[style=Bash]
$ emp cfill items  description:Webseite price:99.99 quantity:1
$ emp cfill items  description:Softwareentwicklung price:25.00 unit:Stunden quantity:5
$ emp cfill items  description:Datenrettung price:250.00 quantity:1
\end{lstlisting}
//TODO: Wie muss man die Function deklariern?

Vor dem rendern überprüfen wir nochmals unseren aktuellen Status:
\begin{lstlisting}[style=Bash]
$ emp show ../../invoice.htm 
\end{lstlisting}
Alle Werte sollten nun grün oder türkis dargestellt werden. Grün symbolisiert das die Variablen im aktuellen Ordner erstellt wurden, türkise Variablen befinden sich hingegen in einem übergeordneten Verzeichnis.

Das Rendern erfolgt mit dem render-Befehl:
\begin{lstlisting}[style=Bash]
$ emp render ../../invoice.htm ./invoice.htm 
\end{lstlisting}
